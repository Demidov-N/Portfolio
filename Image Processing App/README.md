
# CS3500

**Copied from the Computer Science Project: https://github.khoury.northeastern.edu/demidov/CS3500**


Hello this program is a simple Image Processer that can support Flipping, changing brightness, grayscaling, etc.

It consists of command line application and GUI application

To run GUI, double click `ImageEditor.jar`, to run in the command line mode, see examples below

Program supports:
- Image upload, save and download
- Containing several images
- Works with most of the popular image formats

Program Requires Java 11 to run the `.jar` file in the root folder, or Java JDK in order to use the classes the project is used

# [----- Examples -----]
Design structure of classes is located at `res/ClassDiagram.jpeg`

we use a koala image and peacock image as our primary example obtained from http://clipart-library.com/clipart/zTX59E6Lc.htm
. The peacock image obtained from http://clipart-library.com/clipart/38274.htm

This website allows for personal use.

You can find the images in `res/koala.ppm` and `res/peacock.png`.
An example of all the transformations can be found in "res/examples". 
New examples and variations of new transformations
can be found in "res/newExamples". They are archived but can be generated by the 
script file below, based on the initial images in `res/` folder


Example script file for images is `res/commandLine.txt`. To work it should be 
executed from the project folder.



The jar file is located in res folder. In order to run the script file, 
run this:
```shell
# if running from project folder
java -jar ImageEditor.jar -file res/commandLine.txt

# if running a text version of the script
java -jar ImageEditor.jar -text

# if running GUI
java -jar ImageEditor.jar 
```

Example of the GUI is located in the project folder under name `ProgramScreenshot.png`

# [---------- Implementation details ---------]

# [Model]

Model has **ImageProcessor** Interface with a specific **ImageProcessorModel**
The ImageProcessor can load save transform or get an Image.
IO responsibilities delegated to controller instead of Model

All the transformations are done through function objects that use the **Transformation**
Interface and are tasked with taking an Image and returning a new Image with the transformation applied.

A **TransformationUtil** class exists to help with Trasnformations. It allowed us to abstract some of the trasnformation functions such as kernel and image processing using a matrix.

Images are represented in our Model through the **GenericImage** Interface which allows the user to get all the necassary information about an Image.
GenericImage parametrizes over classes that extend **RGB**. **Image** Is the simple Image Interface used that can support RGB pixel type but if more complex pixel information is needed one can extend RGB to make a more advanced class, while extending GenericImage to have an Image that can accomadate more pixel data.
 **BuffImage** class implements Image Interface and uses buffer Image


Specific pixel values are represented by an **RGB** class. Uses the color class as composition as to allow for alpha in the future

# [Controller]

The controller has a **ImgProcessorController** which only has a run method

**ScriptController** implements ImgProcessorController and allows for a simple script based controller

ScriptController uses **ImgProcessorCommand** to map all the Controller commands to ImgProcessorCommands that automatically call the ImgProcessor to do something

**ImageReader** is a utility class that handles read and write of the images. 

# [View]

**ImgProcessorView** is an interface that has one **ImgProcessorTextView** implemented class whose only task is to view an Image


# [UPDATE: Assignment 5 Changes]

### Design Updates
We have made several changes in the assignment 5 taken into account 
new requirements and the feedback received from the previous homework
- `ImageReader` relocation - based on the feedback we realized we had a flaw
  in saving and loading images, as we needed to save them inside the controller instead
  of the model. Which is why we relocated `ImageReader` to the controller and made changes
  to accommodate the design:
  - Removed package-private constructors of `Image` implementations
  - Now `ImageReader.read` uses `setPixelAt` on empty image to create a new 
    one, instead of passing array of lists directly inside the constructor
  - `ImageReader.save` for .ppm image is not changed, as it was passing image directly

- `Image` **Interface implementations** - previously we had class
  `SimpleImage` abstract class and `PPMImage`, extension of abstract class. As
  we needed to add the support for other image types, we thought to generalize
  our image to one implementation that is going to work for all the images: `BuffImage`, the 
  buffered image. It has one public constructor that creates an empty transparent image 
  with specified width, height, and maxValue. It has all the same methods as
  in `Image` interface with approximately same implementations as `PPMImage`
- `RGB` - as we wanted to create the support for all the types of images, we added additional
  alpha channel for our RGB pixels. If the file is saved under the format with no alpha channel,
  on save it is just going to be ignored. Also added method `getRGBByte` in order to transfer the 
  values into the `BufferedImage`
- Previously we had function object for every transformation command. Now we have just
    one command, where we pass the transformation object. Exception is `Brighten` as this command 
    behaves differently if we give positive or negative value.
- Now the controller behaves the same way if it has the script file or when it is in interactive
    mode, it is going to run until it encounters stop command or there is no lines left to execute.

### New requirement updates
We also added support for new requirements for the Assignment 5
- Created new `Luma`, `Sepia` `Sharpen`, `Blur` transformations and their commands 
- Controller loads and saves images in different formats, like jpg, png, bmp, gif. Also 
  has a support to convert from one to another. Also added method `getRGBByte` to get `int` 
  version of the pixel to pass into `BufferedImage`.
  - For that we have updated `RGB` to support alpha channel, to generalize all the images.
    If we save the image in format with no alpha channel, we just ignore it.
  - We use `ImageIO.read` and `ImageIO.save` to load and save images from the file system, if 
    the format of saved or loaded image is not `.ppm`. If it is `.ppm`, I use methods created 
    in previous assignment. 


# [UPDATE: Assignment 6 Changes]
- created new **ControllerFeatures** Interface with all the features that the new GUI controller should support
- implemented that Interface in the **GUIController** that is now the new controller for the GUI
- Made a **Histogram** class that can take an image and create a color Histogram
- made a **ViewImage** and a **ViewModel** that are view only models and images that can be used by the new GUI
- created a **ImageGUI** Interface with all the methods necassary for the controller to use the gui
- implemented it in **ImageProcessorGUI** which is the programs GUI
- Being used by ImageProcessorGUI are **HeaderPanel**, **HistogramPanel**, **InfoPanel** and **ToolbarPanel**
- Updated Controller so that it automatically runs with the GUI and can be given CLI args to run using scrips or text